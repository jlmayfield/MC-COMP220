\documentclass[10pt]{article}
\usepackage{amsmath}
\usepackage{setspace}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{
  %frame=tb,
  language=C++,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}



\setlength{\textheight}{9in} \setlength{\topmargin}{-.5in}
\setlength{\textwidth}{6.5in} \setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}

\title{COMP220 - Lab 8}
\author{ }
\date{Fall 2015}

\begin{document}
\maketitle
\thispagestyle{empty}

\begin{abstract}
In this lab you'll work some basic exercises on Big-O and algorithm analysis. Write solutions on this sheet and bring the sheet to class tomorrow. We'll discuss it, then you'll hand it in.
\end{abstract}

\begin{enumerate}
\item Determine the Big-O for each of the following functions.
\begin{enumerate}
\item $3n+1500$
\vspace{.35in}
\item $\dfrac{x\log x}{25} - 5x + 3x^3$
\vspace{.35in}
\item $(n+1)(n+2)$
\vspace{.35in}
\item $10^9$
\vspace{.35in}
\item $\log y + 135 + \dfrac{y}{2}$
\vspace{.35in}
\end{enumerate}
\item A lot of looped/repeated code generates a pattern of incrementally increasing work. For example, the first iteration carries out 1 operation, then the next 2, the next 3, and so on up to some $n$. This pattern, called the \textit{arithmetic series}, is well studied in mathematics and easy easily expressed with \textit{summation notation}. 
\[
\sum\limits_{i=1}^{n} i = 1 + 2 + \ldots + (n-1) + n =  \dfrac{n(n+1)}{2}
\]
For now, the import thing to notice is that we can determine the total of the sum without explicitly doing all the the addition by using the formula on the right in the above equation. What's the Big-O of this summation? 
\newpage \thispagestyle{empty}
\item Consider the following loop that counts through $[0,n)$:
\begin{center}
\begin{lstlisting}
for(int i{0} ; i < n ; ++i){ 
}
\end{lstlisting}
\end{center}
If the initialization of $i$ costs one operation, the $<$ costs one operation each time it executes, and $++$ costs 2 operators (because it's the same as $i=i+1$) each time it executes, then what's the total cost of this loop and what's the Big-O? [Double check your answer before moving on from this question]
\vspace{1in}
\item Rewrite the loop from the previous question so that it counts through only the even numbers. Do this without doing anything inside the loop. To check yourself, write the loop in a main procedure so that you can pick an $n$ and print the numbers like this:
\begin{lstlisting}
int n{ ... }; // pick a number for n, not too big, not too small
for(int i{0}; ... ; ... ){
   std::cout << i << '\n';
}
\end{lstlisting}
Intuitively we'd expect this to do half as much work as the original loop, what's that mean in Big-O terms? To check your intuition determine the exact number of operations needed for the loop and then Big-O of that. 
\vspace{2in}
\item Repeat the previous exercise but write a loop that counts by 5, i.e. counts through every fifth number in $[0,n)$. 
\newpage \thispagestyle{empty}
\item What do the previous exercises tell you about the effect of taking fixed sized steps with a counting loop? 
\vspace{2in}
\item Consider the following nested loop structure:
\begin{lstlisting}
for(int i{0}; i < n; i++){
  for(int j{0}; j < n; j++){  
  }
}
\end{lstlisting}
Ignoring the interaction with the other loop, determine the exact number of operations and Big-O of each loop. Now, what's the exact operations done by the whole thing and what's the Big-O of that? To better understand the execution of these loops, code this up to print $i$ and $j$ like this:
\begin{lstlisting}
int n{ ... };
std::cout << "i   js\n";
for( int i{0}; i < n ; ++i){
   std::cout << i << "  ";
   for( int j{0}; j < m; ++j){
      std::cout << j << ' ';
   }
   std::cout << "\n";
}
\end{lstlisting}
\newpage \thispagestyle{empty}
\item Consider the following nested loop structure:
\begin{lstlisting}
for(int i{0}; i < n; i++){
  for(int j{i}; j < n; j++){  
  }
}
\end{lstlisting}
Code these loops up in the same fashion as the previous loop and see what they do. What's different about this code compared to the previous nested loop? Will it do more, less, or the same amount of work as the previous code? Now... if $n=5$, how many times is the inner loop executed and how many total operations does it carry out on each of those execution? What's the Big-O of this code? Why? 
\vspace{2in}
\item Would changing the step size of either loop in either of the above two examples change the complexity of the code?
\vspace{2in}
\item These loops tell us something about the efficiency limitations of our iterative strategy, what is it? 
\end{enumerate}


\end{document}